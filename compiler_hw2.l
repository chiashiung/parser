%{
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include "y.tab.h"	/* header file generated by bison */
	
	#define MAX	256

	extern char msg[256];

	int linenum = 0;
	int charnum = 0;
	char temp[256];

	void nlinecount(char *word);
	void create();
	int lookup(char *word);
	int insert(char *word);
	void dump();
	int hash(char *word);
%}

/* Define regular expression label */
digit           [0-9]
letter			[A-Za-z]
inumber			(-?{digit}+)
fnumber         (-?({digit}+|{digit}*\.{digit}+)([eE][+-]?{digit}+)?f?)
id              ([\_\$]|{letter})+([\_\$]|{letter}|{digit})*
inv_id			([\^\#]|{digit})+([\_\$]|{letter}|{digit})*
ws				[ \t]
inv_str         \"[\"]+\"|\'[^(\'|\n)]*\'|\"[^(\"|\n)]*|\"[^(\"|\n)]*\\\"
string          \"[^\n]*\"
comments        "/*"(.|\n)*"*/"
comment         ([/]{2}.*)\n


/* Rule Section*/
%%
<<EOF>>     	{linenum++;yyterminate();}
"+" 			{strcat(msg,"+");return PLUS;}			
"-"				{strcat(msg,"-");return MINUS;}
"*" 			{strcat(msg,"*");return MUL;}
"/"				{strcat(msg,"/");return DIV;}
"%"				{strcat(msg,"%");return MOD;}
"++" 			{strcat(msg,"++");return INC;}
"--" 			{strcat(msg,"--");return DEC;}

"=" 			{strcat(msg,"=");return '=';}
"+="			{strcat(msg,"+=");return ADD_ASSIGN;}
"-="			{strcat(msg,"-=");return SUB_ASSIGN;}
"*="			{strcat(msg,"*=");return MUL_ASSIGN;}
"/="			{strcat(msg,"/=");return DIV_ASSIGN;}
"%="			{strcat(msg,"%=");return MOD_ASSIGN;}

"<"				{strcat(msg,"<");return LT;}
">"				{strcat(msg,">");return GT;}
"<=" 			{strcat(msg,"<=");return LEQ;}
">=" 			{strcat(msg,">=");return GEQ;}
"==" 			{strcat(msg,"==");return EQ;}
"!=" 			{strcat(msg,"!=");return NEQ;}

"&&" 			{strcat(msg,"&&");return LAND;}
"||" 			{strcat(msg,"||");return LOR;}
"!"				{strcat(msg,"!");return NOT;}

"("				{strcat(msg,"(");return '(';}
")"				{strcat(msg,")");return ')';}
"["				{strcat(msg,"[");return '[';}
"]"				{strcat(msg,"]");return ']';}
"{"				{strcat(msg,"{");return '{';}	
"}"				{strcat(msg,"}");return '}';}

"."				{strcat(msg,".");return '.';}
","				{strcat(msg,",");return ',';}
";"				{strcat(msg,";");return ';';}
":"				{strcat(msg,":");return ':';}
"\n"            {linenum++;return NEWLINE;}

boolean			{strcat(msg,"boolean");return BOOL;}
char			{strcat(msg,"char");return CHAR;}
int				{strcat(msg,"int");return INT;}
float			{strcat(msg,"float");return FLOAT;}
string			{strcat(msg,"string");return STRING;}
void			{strcat(msg,"void");return VOID;}
class			{strcat(msg,"class");return CLASS;}

final			{strcat(msg,"final");return FINAL;}
new				{strcat(msg,"new");return NEW;}
static			{strcat(msg,"static");return STATIC;}

public			{strcat(msg,"public");return PUBLIC;}
protected		{strcat(msg,"protected");return PROTECTED;}
private			{strcat(msg,"private");return PRIVATE;}

true			{strcat(msg,"true");return TRUE;}
false			{strcat(msg,"false");return FALSE;}

if				{strcat(msg,"if");return IF;}
else			{strcat(msg,"else");return ELSE;}
while			{strcat(msg,"while");return WHILE;}
for				{strcat(msg,"for");return FOR;}

print			{strcat(msg,"print");return PRINT;}
return			{strcat(msg,"return");return RETURN;}
read			{strcat(msg,"read");return READ;}

break |
byte |
case |
catch |
continue |
default |
do |
double |
extend |
finally |
implements |
long |
short |
switch |
this |
try 			{;}
{inumber}       {sscanf(yytext,"%d",&yylval.int_val);
				 if(yylval.int_val>0) return PINT_LIT;
				 else return NPINT_LIT;
				}
{fnumber}       {sscanf(yytext,"%f",&yylval.float_val);return FLOAT_LIT;}
{id}			{sprintf(temp,"%s",yytext);strcat(msg,temp);yylval.id_val = strdup(yytext);return ID;}
{inv_id}		{printf("Line:%d,1st char:%d,\"%s\" is a \"invalid identifier\"\n",linenum+1,charnum+1,yytext);}
{ws}			{sprintf(temp,"%s",yytext);strcat(msg,temp);}
{inv_str}       {printf("Line:%d,1st char:%d,%s is a \"invalid string\"\n",linenum+1,charnum+1,yytext);}
{string}        {yylval.s_val = strdup(yytext);return STRING_LIT;;}
{comment}       {linenum++;charnum=0;
				 printf("Line %d : %s%s",linenum,msg,yytext);
				 memset(msg,0,256);}
{comments}		{nlinecount(yytext);}
.				{;}
%%
int yywrap(void)
{
    return 1;
}

void nlinecount(char* word){
	int count=0;
	for(int i=0;i<yyleng;i++){
		count++;
		if((int)word[i]==10){
			printf("Line %d : %s\n",linenum+1,msg);
			linenum++;
			count=0;
			memset(msg,0,256);
		}
		else{
			sprintf(temp,"%c",word[i]);
			strcat(msg,temp);
		}
	}
	charnum += count;
}

struct id_data{
	char* id_name;
	struct	id_data *next;
};

struct id_data *s;	//for symbol table

void create(){
	s = malloc(sizeof(struct id_data) * MAX);
	for(int i=0;i<MAX;i++)
		s[i].next = NULL;
}

int lookup(char *word){
	int hashnum = hash(word);
	struct id_data *p = &s[hashnum];
	p = p->next;
	while(p){
		if(strcmp(p->id_name,word)==0) return hashnum;
		p = p->next;
	}
	return -1;
}

int insert(char *word){
	int hashnum = hash(word);
	struct id_data *node;
	if(lookup(word)>=0){
		//printf("%s is already in the table\n",word);
		return -1;
	}
	node = (struct id_data *) malloc(sizeof(struct id_data));
	if(s[hashnum].next==NULL)
		node->next = NULL;
	else
		node->next = s[hashnum].next;
	s[hashnum].next = node;
	node->id_name = (char *) malloc(strlen(word)+1);
	strcpy(node->id_name,word);
	return hashnum;
}

void dump(){
	printf("The symbol table contains:\n");
	for(int i=0;i<MAX;i++){
		int count=0;
		struct id_data *p =  &s[i];
		p = p->next;
		if(p){
			printf("index %d:\n",i);
			while(p){
				printf("	%-10s",p->id_name);
				count++;
				if((count%5)==0) printf("\n");
				p = p->next;
			}
			if((count%5)!=0) printf("\n");
		}
	}
}

int hash(char *word){
	int sum = 0;
	int hashnum;
	for(int i=0;i<strlen(word);i++)
		sum += (int)word[i];
	hashnum = sum % MAX;
	return hashnum;
}
